! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! Main Program File
! 
! Generated by KPP-2.2.3_rs5 symbolic chemistry Kinetics PreProcessor
!       (http://www.cs.vt.edu/~asandu/Software/KPP)
! KPP is distributed under GPL, the general public licence
!       (http://www.gnu.org/copyleft/gpl.html)
! (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
! (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech
!     With important contributions from:
!        M. Damian, Villanova University, USA
!        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany
! 
! File                 : kpp_Main.f90
! Time                 : Tue Sep 16 16:29:12 2014
! Working directory    : /scratch/daint/charlesj/extended_box_model/kpp-2.2.3
! Equation file        : kpp.kpp
! Output root filename : kpp
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! MAIN - Main program - driver routine
!   Arguments :
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PROGRAM kpp_Driver

  USE kpp_Model
  USE kpp_Initialize, ONLY: Initialize
  USE Wrap_NETCDF
  USE kpp_Parameters, ONLY: idim_spot, jdim_spot, kdim_spot, &
       idim_loc_s, jdim_loc_s, kdim_loc_s, idim_loc_e, jdim_loc_e, kdim_loc_e, &
       NMONITOR, TAG, ref_sol, ncells
  USE omp_lib

#if defined(__HAVE_AMESTER)
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_CHAR, C_INT, C_CHAR
#endif
  IMPLICIT NONE

  INCLUDE "mpif.h"

#if defined(__HAVE_AMESTER)
  CHARACTER(len=40) :: amesterFilename
  INTEGER :: amesterOutFlag

  INTEGER :: num_args, ix
  CHARACTER(len=12), DIMENSION(:), ALLOCATABLE :: args

  INTERFACE
     FUNCTION initialize_amester_manually ( useAmester, addressName, portNumber ) BIND( C, NAME="initialize_amester_manually" )
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_CHAR, C_INT, C_CHAR
       !IMPORT :: C_PTR, C_INT, C_CHAR
       INTEGER( C_INT ) :: initialize_amester_manually
       INTEGER( C_INT ) :: useAmester
       CHARACTER( kind=C_CHAR ), DIMENSION( * ) :: addressName
       INTEGER( C_INT ), VALUE :: portNumber
     END FUNCTION initialize_amester_manually

     FUNCTION start_measuring ( filename, label ) BIND( C, NAME="start_measuring" )
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_CHAR, C_INT, C_CHAR
       INTEGER( C_INT ) :: start_measuring
       CHARACTER( kind=C_CHAR ), DIMENSION( * ) :: filename
       CHARACTER( kind=C_CHAR ), DIMENSION( * ) :: label
     END FUNCTION start_measuring

     FUNCTION stop_measuring ( ) BIND( C, NAME="stop_measuring" )
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_CHAR, C_INT, C_CHAR
       INTEGER( C_INT ) :: stop_measuring
     END FUNCTION stop_measuring

     FUNCTION close_amester ( ) BIND( C, NAME="close_amester" )
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_NULL_CHAR, C_INT, C_CHAR
       INTEGER( C_INT ) :: close_amester
     END FUNCTION close_amester

  END INTERFACE
#endif

  REAL(kind=dp) :: T, DVAL(NSPEC)
  REAL(kind=dp) :: RSTATE(20), RCNTRL(20)
  REAL(kind=dp) :: TTS, TTS_init, TTS_final
  REAL(kind=dp) :: ETS, ETS_init, ETS_final
  REAL(kind=dp) :: device_ETS, device_ETS_init, device_ETS_final
  REAL(kind=dp) :: ETS_init_total, ETS_final_total
  REAL(kind=dp) :: device_ETS_init_total, device_ETS_final_total
  REAL(kind=dp) :: rel_acc, weight

  INTEGER :: ISTATE(20), ICNTRL(20)
  INTEGER :: i, nbit, ii, jj, kk, act_hour

  REAL(kind=dp) :: time_init, time_final

  !~~~> Initialization 

#if defined(__HAVE_AMESTER)
  num_args = COMMAND_ARGUMENT_COUNT()
  ALLOCATE(args(num_args))
  DO ix = 1, num_args
     CALL GET_COMMAND_ARGUMENT(ix,args(ix))
  END DO
#endif

  ! get energy counter at startup
!!$  CALL SYSTEM_CLOCK(COUNT_RATE=CLOCK_RATE, COUNT_MAX=CLOCK_MAX) ! Set rates
  !CALL get_time_omp(time_init)

  CALL energy(ETS_init_total)
  CALL device_energy(device_ETS_init_total)

  DO i = 1, 20
     ISTATE(i) = 0
     ICNTRL(i) = 0
     RSTATE(i) = 0.0d0
     RCNTRL(i) = 0.0d0
  END DO

  ICNTRL(2) = 1
  ICNTRL(3) = 3

  STEPMIN = 0.0d0
  STEPMAX = 0.0d0

  TTS = 0.0d0
  ETS = 0.0d0
  device_ETS = 0.0d0

  nbit = 0
  global_ISTATS(:) = 0

  DO i=1,NVAR
     RTOL(i) = 1.0d-2
     ATOL(i) = 1.0d-2
  END DO

  rel_acc = 0.0D0
  weight = 0.0D0

  CALL Initialize()
  CALL InitSaveData()

#if defined(__HAVE_AMESTER)
  amesterOutFlag = initialize_amester_manually(1,"blade84",9999)
#endif

  CALL OMP_SET_DYNAMIC(.FALSE.)

  DO act_hour=0,23

     TSTART_INT = act_hour * 3600.0D0
     TEND_INT = TSTART_INT + 30*120.0D0

     ! Get all initial values on all of the idim*jdim*kdim boxes at time = act_hour
!!$     CALL Get_Boxes(initial_conc_from_file, temperature_from_file, act_hour) 
     CALL Get_Boxes(vinitial_conc_from_file, vtemperature_from_file, act_hour)

     !~~~> Time loop
     T = TSTART_INT

#if defined(__HAVE_AMESTER)
     !if (verbose && strcmp(argv[4],"null"))
     WRITE (amesterFilename, "(I0)") INT(T)
     amesterFileName = TRIM(TRIM("vesuv_KPP/"//TRIM(args(1))//"_time_"//amesterFileName)//".dat")//c_null_char

     !write(*,*) "<"//amesterFileName//">"

     amesterOutFlag = start_measuring(amesterFilename, amesterFilename)
#endif

     kron: DO WHILE (T < TEND_INT)

!!$        CALL SYSTEM_CLOCK(CLOCK_TS_1)
        !call get_time(time_ts_init)

        ! get energy counter at startup
        CALL energy(ETS_init)
        CALL device_energy(device_ETS_init)

        TTS_init = MPI_WTIME()

        nbit = nbit + 1

        ISTATS(:) = 0

        TIME = T

        CHI = CHIBE( T/60.0d+00, 48.0d+00, 2.0d+00, TAG )

        CALL GetMass( C, DVAL )

        !CALL Update_SUN() 

!!$        CALL SYSTEM_CLOCK(CLOCK_INTEGRATOR_1)
        !call get_time(time_integrator_init)

        CALL INTEGRATE( TIN = T, TOUT = T+DT, ISTATUS_U = ISTATE, & 
             RSTATUS_U = RSTATE, ICNTRL_U = ICNTRL, RCNTRL_U = RCNTRL, NHOUR = act_hour )

!!$        CALL SYSTEM_CLOCK(CLOCK_INTEGRATOR_2)
        !call get_time(time_integrator_final)

        TTS_final = MPI_WTIME()

!!$        CALL SYSTEM_CLOCK(CLOCK_TS_2)
        !call get_time(time_ts_final)

!!$        CALL time_to_file(nbit, T)

        ! get energy counter at end
        CALL energy(ETS_final)
        CALL device_energy(device_ETS_final)

        TTS = TTS + (TTS_final - TTS_init)
        ETS = ETS + (ETS_final - ETS_init)
        device_ETS = device_ETS + (device_ETS_final - device_ETS_init)

        global_ISTATS(:) = global_ISTATS(:) + ISTATS(:)

        T = RSTATE(1)

     END DO kron
     !~~~> End Time loop

#if defined(__HAVE_AMESTER)
     amesterOutFlag = stop_measuring()
#endif

     CALL GetMass( C, DVAL )

!!$     WRITE(6,990) (T-TSTART_INT)/(TEND_INT-TSTART_INT)*100, T,     &
!!$          ( TRIM(SPC_NAMES(MONITOR(i))), & 
!!$          VARTOT(MONITOR(i),idim_spot,jdim_spot,kdim_spot)/CFACTOR, i=1,NMONITOR )

     WRITE(6,990) (T-TSTART_INT)/(TEND_INT-TSTART_INT)*100, T,     &
          ( TRIM(SPC_NAMES(MONITOR(i))), &
          VVARTOT(MONITOR(i),v_spot)/CFACTOR, i=1,NMONITOR )

!!$     CALL values_to_file(T)

     TIME = T
     CALL SaveData()

  END DO ! end act_hour loop

#if defined(__HAVE_AMESTER)
  amesterOutFlag = close_amester()
#endif

  CALL CloseSaveData()

  !CALL get_time_omp(time_final)

  ! get energy counter at end
  CALL energy(ETS_final_total)
  CALL device_energy(device_ETS_final_total)

  i = 1
  DO WHILE (i < NMONITOR + 1)
     rel_acc = rel_acc + (ref_sol(i) - VARTOT(MONITOR(i),idim_spot,jdim_spot,kdim_spot)/CFACTOR)**2
     weight = weight + ref_sol(i)**2
     i = i + 1
  END DO
  rel_acc = SQRT(rel_acc/weight)

  WRITE(6,*)
  WRITE(6,992) 'Total Rosenbrock function calls                 = ', global_ISTATS(Nfun)
  WRITE(6,992) 'Total Rosenbrock jacobian calls                 = ', global_ISTATS(Njac)
  WRITE(6,992) 'Total Rosenbrock steps                          = ', global_ISTATS(Nstp)
  WRITE(6,992) 'Total Rosenbrock accepted steps                 = ', global_ISTATS(Nacc)
  WRITE(6,992) 'Total Rosenbrock rejected steps                 = ', global_ISTATS(Nrej)
  WRITE(6,992) 'Total Rosenbrock LU decompositions              = ', global_ISTATS(Ndec)
  WRITE(6,992) 'Total Rosenbrock forward/backward substitutions = ', global_ISTATS(Nsol)
  WRITE(6,992) 'Total Rosenbrock singular matrix decompositions = ', global_ISTATS(Nsng)
  WRITE(6,*)
  WRITE(6,999) 'Absolute Tolerance = ', ATOL(1)
  WRITE(6,999) 'Relative Tolerance = ', RTOL(1)
  WRITE(6,*)
  WRITE(6,995) 'ICNTRL = ', ICNTRL
  WRITE(6,996) 'RCNTRL = ', RCNTRL
  WRITE(6,*)
  WRITE(6,998) 'Subgrid coordinates (lon.)  = ', idim_loc_s, idim_loc_e
  WRITE(6,998) 'Subgrid coordinates (lat.)  = ', jdim_loc_s, jdim_loc_e
  WRITE(6,998) 'Subgrid coordinates (vert.) = ', kdim_loc_s, kdim_loc_e
  WRITE(6,*)
  WRITE(6,992) 'Total number of grid points = ', ncells
  WRITE(6,*)
  WRITE(6,*)   '******** One Timestep (average of all cells) ********'
  WRITE(6,992) 'Rosenbrock steps = ', INT(global_ISTATS(Nstp)/(ncells*nbit))
  WRITE(6,993) 'TTS              = ', TTS/nbit, ' s'
  WRITE(6,994) 'ETS              = ', ETS/nbit, ' J'
  WRITE(6,994) 'Device ETS       = ', device_ETS/nbit, ' J'
  WRITE(6,*)
  WRITE(6,991) 'Total number of timesteps = ', nbit 
  WRITE(6,*)
  WRITE(6,*)   '******** Total Timesteps ********'
  WRITE(6,992) 'Rosenbrock steps = ', INT(global_ISTATS(Nstp)/ncells)
  WRITE(6,993) 'TTS              = ', TTS, ' s'
  WRITE(6,994) 'ETS              = ', ETS, ' J'
  WRITE(6,994) 'Device ETS       = ', device_ETS, ' J'
  WRITE(6,*)
  WRITE(6,*)   '******** Entire application ********'
  WRITE(6,994) 'ETS              = ', ETS_final_total-ETS_init_total, ' J'
  WRITE(6,994) 'Device ETS       = ', device_ETS_final_total-device_ETS_init_total, ' J'
  WRITE(6,*)
  WRITE(6,997) 'Relative accuracy to ref. sol. = ', rel_acc 
  WRITE(6,*)

990 FORMAT(F6.1,'%. T=',E9.3,2X,200(A,'=',E11.4,'; '))
991 FORMAT(A,I4)
992 FORMAT(A,I11)
993 FORMAT(A,F11.3,A)
994 FORMAT(A,F11.1,A)
995 FORMAT(A,20(I7,","))
996 FORMAT(A,20(F7.2,","))
997 FORMAT(A,E11.4)
998 FORMAT(A,I5,I5)
999 FORMAT(A,F6.2)

  !==============================================================================
CONTAINS
  !==============================================================================
  
  SUBROUTINE get_time_omp(t)
    IMPLICIT NONE
    REAL (kind=8), INTENT(out) :: t
    t = omp_get_wtime()
  END SUBROUTINE get_time_omp

  SUBROUTINE time_to_file(i, t)
    IMPLICIT NONE
    INTEGER, INTENT(in) :: i
    REAL (kind=8), INTENT(in) :: t
    INTEGER, PARAMETER :: out_unit=20
    LOGICAL :: exist

    INQUIRE(file="./output_time_step.txt", exist=exist)
    IF (exist) THEN
       OPEN(out_unit, file="./output_time_step.txt", status="old", position="append", action="write")
    ELSE
       OPEN(out_unit, file="./output_time_step.txt", status="new", action="write")
    END IF

    IF (CLOCK_TS_2 - CLOCK_TS_1 >= 0) THEN
       CLOCK_TS = CLOCK_TS_2 - CLOCK_TS_1
    ELSE
       CLOCK_TS = CLOCK_TS_2 - CLOCK_TS_1 + CLOCK_MAX
    ENDIF

    IF (CLOCK_INTEGRATOR_2 - CLOCK_INTEGRATOR_1 >= 0) THEN
       CLOCK_INTEGRATOR = CLOCK_INTEGRATOR_2 - CLOCK_INTEGRATOR_1
    ELSE
       CLOCK_INTEGRATOR = CLOCK_INTEGRATOR_2 - CLOCK_INTEGRATOR_1 + CLOCK_MAX
    ENDIF

    IF (CLOCK_INTEGRATOR_INIT_2 - CLOCK_INTEGRATOR_INIT_1 >= 0) THEN
       CLOCK_INTEGRATOR_INIT = CLOCK_INTEGRATOR_INIT_2 - CLOCK_INTEGRATOR_INIT_1
    ELSE
       CLOCK_INTEGRATOR_INIT = CLOCK_INTEGRATOR_INIT_2 - CLOCK_INTEGRATOR_INIT_1 + CLOCK_MAX
    ENDIF

    IF (CLOCK_INTEGRATOR_SAVE_2 - CLOCK_INTEGRATOR_SAVE_1 >= 0) THEN
       CLOCK_INTEGRATOR_SAVE = CLOCK_INTEGRATOR_SAVE_2 - CLOCK_INTEGRATOR_SAVE_1
    ELSE
       CLOCK_INTEGRATOR_SAVE = CLOCK_INTEGRATOR_SAVE_2 - CLOCK_INTEGRATOR_SAVE_1 + CLOCK_MAX
    ENDIF

    IF (CLOCK_INTEGRATOR_CORE_2 - CLOCK_INTEGRATOR_CORE_1 >= 0) THEN
       CLOCK_INTEGRATOR_CORE = CLOCK_INTEGRATOR_CORE_2 - CLOCK_INTEGRATOR_CORE_1
    ELSE
       CLOCK_INTEGRATOR_CORE = CLOCK_INTEGRATOR_CORE_2 - CLOCK_INTEGRATOR_CORE_1 + CLOCK_MAX
    ENDIF

!!$    WRITE (*,*) "Time-Step-full:      ",DBLE(CLOCK_TS)/DBLE(CLOCK_RATE), "s"
!!$    WRITE (*,*) "Integrator-full:     ",DBLE(CLOCK_INTEGRATOR)/DBLE(CLOCK_RATE), "s", &
!!$         (DBLE(CLOCK_TS)/DBLE(CLOCK_INTEGRATOR))/DBLE(CLOCK_RATE)*100d0, " %"
!!$    WRITE (*,*) "Integrator-init:     ",DBLE(CLOCK_INTEGRATOR_INIT)/DBLE(CLOCK_RATE), "s", &
!!$         (DBLE(CLOCK_INTEGRATOR_INIT)/DBLE(CLOCK_INTEGRATOR))*100d0, " %"
!!$    WRITE (*,*) "Integrator-save:     ",DBLE(CLOCK_INTEGRATOR_SAVE)/DBLE(CLOCK_RATE), "s", &
!!$         (DBLE(CLOCK_INTEGRATOR_SAVE)/DBLE(CLOCK_INTEGRATOR))*100d0, " %"
!!$    WRITE (*,*) "Integrator-core:     ",DBLE(CLOCK_INTEGRATOR_CORE)/DBLE(CLOCK_RATE), "s", &
!!$         (DBLE(CLOCK_INTEGRATOR_CORE)/DBLE(CLOCK_INTEGRATOR))*100d0, " %"

#ifdef FINE_TIMING
    WRITE (*,*) "Int. core prep-mat:  ",DBLE(CLOCK_PREPAREMATRIX_FULL)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s", &
         (DBLE(CLOCK_PREPAREMATRIX_FULL)/DBLE(CLOCK_INTEGRATOR_CORE))/omp_get_max_threads()*100d0, " %"
    WRITE (*,*) "Int. core axpy:      ",DBLE(CLOCK_AXPY)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s", &
         (DBLE(CLOCK_AXPY)/DBLE(CLOCK_INTEGRATOR_CORE))/omp_get_max_threads()*100d0, " %"
    WRITE (*,*) "Int. core kkp-solve: ",DBLE(CLOCK_KPPSOLVE)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s", &
         (DBLE(CLOCK_KPPSOLVE)/DBLE(CLOCK_INTEGRATOR_CORE))/omp_get_max_threads()*100d0, " %"
    WRITE (*,*) "Int. core fun-t:     ",DBLE(CLOCK_FUNTEMPLATE)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s", &
         (DBLE(CLOCK_FUNTEMPLATE)/DBLE(CLOCK_INTEGRATOR_CORE))/omp_get_max_threads()*100d0, " %"
    WRITE (*,*) "Int. core jac-t:     ",DBLE(CLOCK_JACTEMPLATE)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s", &
         (DBLE(CLOCK_JACTEMPLATE)/DBLE(CLOCK_INTEGRATOR_CORE))/omp_get_max_threads()*100d0, " %"
#endif
#ifdef DETAILED_TIMING
    WRITE (*,*) "Integrator-LU-full:  ",DBLE(CLOCK_LU_FULL)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s"
    WRITE (*,*) "Integrator-LU-core:  ",DBLE(CLOCK_LU)/DBLE(CLOCK_RATE)/omp_get_max_threads(), "s"
    WRITE (*,*) "LU full-calls: ",DBLE(CLOCK_LU_FULL_CALLS)/omp_get_max_threads(), "; LU core-calls: ", &
         DBLE(CLOCK_LU_CALLS)/omp_get_max_threads(), "; LU repeats: ", DBLE(CLOCK_LU_CALLS - CLOCK_LU_FULL_CALLS)/omp_get_max_threads()
#endif
    !    write (*,*) i," ",t," ",ts," ",ti
    WRITE (out_unit,*) i," ",t," ",DBLE(CLOCK_TS)/DBLE(CLOCK_RATE)," ", &
         DBLE(CLOCK_INTEGRATOR)/DBLE(CLOCK_RATE)," ", &
         DBLE(CLOCK_INTEGRATOR_INIT)/DBLE(CLOCK_RATE)," ", &
         DBLE(CLOCK_INTEGRATOR_SAVE)/DBLE(CLOCK_RATE)," ", &
         DBLE(CLOCK_INTEGRATOR_CORE)/DBLE(CLOCK_RATE) !," ", &
    !                                   DBLE(CLOCK_PREPAREMATRIX_FULL)/DBLE(CLOCK_RATE)/omp_get_max_threads()," ", &
    !                                   DBLE(CLOCK_LU_FULL)/DBLE(CLOCK_RATE)/omp_get_max_threads()," ", &
    !                                   DBLE(CLOCK_LU)/DBLE(CLOCK_RATE)/omp_get_max_threads()," ", &
    !                                   DBLE(CLOCK_LU_FULL_CALLS)/omp_get_max_threads()," ", &
    !                                   DBLE(CLOCK_LU_CALLS)/omp_get_max_threads()
    !    write (out_unit,*) "is",i*j
    CLOSE (out_unit)

  END SUBROUTINE time_to_file

  SUBROUTINE values_to_file(T)
    IMPLICIT NONE
    REAL (kind=8), INTENT(in) :: T
    INTEGER :: i
    INTEGER, PARAMETER :: out_unit=20
    LOGICAL :: exist

    INQUIRE(file="output_values.txt", exist=exist)
    IF (exist) THEN
       OPEN(out_unit, file="./output_values.txt", status="old", position="append", action="write")
    ELSE
       OPEN(out_unit, file="./output_values.txt", status="new", action="write")
    END IF

    WRITE(out_unit,990) (T-TSTART_INT)/(TEND_INT-TSTART_INT)*100, T,     &
         ( TRIM(SPC_NAMES(MONITOR(i))), VVARTOT(MONITOR(i),v_spot)/CFACTOR, i=1,NMONITOR )

    CLOSE (out_unit)

990 FORMAT(F6.1,'%. T=',E9.3,2X,200(A,'=',E11.4,'; '))

  END SUBROUTINE values_to_file

  SUBROUTINE device_energy(e)
    IMPLICIT NONE
    REAL (kind=8), INTENT(out) :: e

    OPEN(unit=50, file='/sys/cray/pm_counters/accel_energy' ,action='READ')
    READ(50,*) e
    CLOSE(50)
  END SUBROUTINE device_energy

  SUBROUTINE energy(e)
    IMPLICIT NONE
    REAL (kind=8), INTENT(out) :: e

    OPEN(unit=50, file='/sys/cray/pm_counters/energy' ,action='READ')
    READ(50,*) e
    CLOSE(50)
  END SUBROUTINE energy

END PROGRAM kpp_Driver

! End of MAIN function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


